# TIL: 2025-07-13 - Crontab Environment, Process Locking, and System Logging

## Problem Context
Setting up automated monitoring for the power-monitor script via crontab. The script worked perfectly when run manually but failed silently when executed by cron.

## Key Learnings

### 1. Crontab Environment is Minimal
**Issue**: Cron jobs failing with "duckdb is not installed" despite tool being available in shell.

**Root Cause**: Cron runs with a very minimal environment - `PATH` typically only includes `/usr/bin:/bin`, not user-specific paths like `~/.local/bin`.

**Solution**: Explicitly set PATH in crontab:
```bash
# At the top of crontab
PATH=/home/username/.local/bin:/usr/local/bin:/usr/bin:/bin

# Then your cron jobs
*/5 * * * * /path/to/script.sh
```

**Why This Matters**: Many tools installed via pip, npm, cargo, or manual installation end up in user-specific bin directories that aren't in cron's default PATH.

### 2. Process Locking with `flock`
**Issue**: Risk of multiple cron job instances running simultaneously, potentially causing conflicts.

**Solution**: Use `flock` for simple, reliable process locking:
```bash
*/5 * * * * /usr/bin/flock -n /tmp/my-script.lock /path/to/script.sh
```

**Key Benefits**:
- `-n` flag makes it non-blocking (exits immediately if lock held)
- Automatic cleanup when process exits (even on crashes)
- No need for manual PID file management
- Built into most Linux systems

**Alternative PID File Approach** (more complex):
```bash
# In script
PIDFILE="/tmp/script.pid"
if [ -f "$PIDFILE" ] && kill -0 "$(cat "$PIDFILE")" 2>/dev/null; then
    echo "Already running" >&2
    exit 1
fi
echo $$ > "$PIDFILE"
trap "rm -f '$PIDFILE'" EXIT
```

### 3. System Logging with `logger`
**Issue**: Need reliable logging for cron jobs without manual file management.

**Solution**: Use `logger` command to send output to system logs:
```bash
*/5 * * * * /path/to/script.sh 2>&1 | logger -t my-script
```

**Benefits**:
- Automatic log rotation via system logrotate
- Centralized logging with system logs
- Real-time monitoring: `journalctl -t my-script -f`
- Searchable: `journalctl -t my-script --since "1 hour ago"`
- No manual file size management

**Alternative Approaches**:
```bash
# Custom log file (requires manual rotation)
*/5 * * * * /path/to/script.sh >> /var/log/my-script.log 2>&1

# Silent operation (bad for debugging)
*/5 * * * * /path/to/script.sh >/dev/null 2>&1
```

### 4. Debugging Cron Jobs
**Techniques Learned**:

1. **Check if cron job executes**: `grep my-script /var/log/syslog`
2. **Test exact cron command manually**: Copy the exact command from crontab and run it
3. **Check cron logs**: `journalctl -u cron` or `grep CRON /var/log/syslog`
4. **Verify environment**: Add `env > /tmp/cron-env.txt` to a test cron job

### 5. Error Message Cascading
**Learning**: "Cannot access database" error was misleading - the real issue was "duckdb command not found" due to PATH, but the error handling made it look like a permission problem.

**Takeaway**: In troubleshooting, always check the most fundamental dependencies first (PATH, permissions, file existence) before diving into complex error messages.

## Complete Crontab Best Practice Pattern
```bash
# Set environment
PATH=/home/username/.local/bin:/usr/local/bin:/usr/bin:/bin

# Automated task with locking and logging
*/5 * * * * /usr/bin/flock -n /tmp/task.lock /path/to/script.sh 2>&1 | logger -t task-name
```

This pattern provides:
- ✅ Proper environment setup
- ✅ Prevention of multiple instances
- ✅ Comprehensive logging with rotation
- ✅ Easy monitoring and debugging

## Monitoring Commands
```bash
# Real-time log monitoring
journalctl -t task-name -f

# Check recent activity
journalctl -t task-name --since "30 minutes ago"

# Verify database/file updates
ls -la /path/to/output/files/

# Check cron execution
grep task-name /var/log/syslog | tail -5
```

## When to Use This Pattern
- Any automated script that needs reliable execution
- Scripts that interact with databases or files
- Long-running processes that might overlap
- Scripts using tools not in standard PATH
- Production automation requiring monitoring

## Tools Involved
- `flock` - File locking utility (usually pre-installed)
- `logger` - Send messages to system log (pre-installed)
- `journalctl` - Query systemd journal logs
- `crontab` - Schedule tasks

## Related Concepts
- Process management and locking
- System logging and log rotation
- Environment variables in different contexts
- Unix file locking mechanisms
- Systemd logging infrastructure